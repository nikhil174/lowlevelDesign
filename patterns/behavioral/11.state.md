# State Design Pattern

The State pattern allows an object to change its behavior when its internal state changes. It's useful for modeling systems with distinct states and transitions, such as a vending machine.

## Vending Machine Design

### Requirements & Design
- **Rows:** Each row contains products. Each product has a unique code and price.
- **Cash/Coin Section:** Area to insert cash or coins.
- **Accept Button:** Button to confirm cash/coin insertion.
- **Keypad:** Used to enter the product code.
- **Cancel Button:** Allows user to cancel and get a refund.
- **Cash Change Tray:** Dispenses change if needed.
- **Product Dispense Tray:** Where the selected product is delivered.

### Flow
1. **Idle State:** Machine waits for user interaction.
2. **Accept Money State:** User presses 'Insert Cash', machine changes to accept money.
3. **Money Inserted State:** User inserts money.
4. **Product Selection State:** User presses 'Select Product', enters product code.
5. **Dispense State:** Machine checks money, dispenses product and change.
6. **Returns to Idle State:** Ready for next user.

### State-wise Operations
```java
// State interface
interface VendingMachineState {
    void insertCash(VendingMachine vm, int amount);
    void selectProduct(VendingMachine vm, String code);
    void cancel(VendingMachine vm);
}

// Concrete States
class IdleState implements VendingMachineState {
    public void insertCash(VendingMachine vm, int amount) {
        vm.setBalance(amount);
        vm.setState(new AcceptMoneyState());
        System.out.println("Cash inserted: " + amount);
    }
    public void selectProduct(VendingMachine vm, String code) {
        System.out.println("Insert cash first.");
    }
    public void cancel(VendingMachine vm) {
        System.out.println("Nothing to cancel.");
    }
}

class AcceptMoneyState implements VendingMachineState {
    public void insertCash(VendingMachine vm, int amount) {
        vm.setBalance(vm.getBalance() + amount);
        System.out.println("Additional cash inserted: " + amount);
    }
    public void selectProduct(VendingMachine vm, String code) {
        vm.setState(new ProductSelectionState(code));
        System.out.println("Product selected: " + code);
    }
    public void cancel(VendingMachine vm) {
        System.out.println("Refunding: " + vm.getBalance());
        vm.setBalance(0);
        vm.setState(new IdleState());
    }
}

class ProductSelectionState implements VendingMachineState {
    private String code;
    public ProductSelectionState(String code) { this.code = code; }
    public void insertCash(VendingMachine vm, int amount) {
        System.out.println("Already inserted cash. Select product or cancel.");
    }
    public void selectProduct(VendingMachine vm, String code) {
        System.out.println("Product already selected: " + this.code);
    }
    public void cancel(VendingMachine vm) {
        System.out.println("Refunding: " + vm.getBalance());
        vm.setBalance(0);
        vm.setState(new IdleState());
    }
}

class DispenseState implements VendingMachineState {
    private String code;
    public DispenseState(String code) { this.code = code; }
    public void insertCash(VendingMachine vm, int amount) {
        System.out.println("Dispensing. Please wait.");
    }
    public void selectProduct(VendingMachine vm, String code) {
        System.out.println("Dispensing. Please wait.");
    }
    public void cancel(VendingMachine vm) {
        System.out.println("Cannot cancel. Dispensing in progress.");
    }
}

// Context
class VendingMachine {
    private VendingMachineState state = new IdleState();
    private int balance = 0;
    public void setState(VendingMachineState state) { this.state = state; }
    public void setBalance(int amount) { this.balance = amount; }
    public int getBalance() { return balance; }
    public void insertCash(int amount) { state.insertCash(this, amount); }
    public void selectProduct(String code) { state.selectProduct(this, code); }
    public void cancel() { state.cancel(this); }
}

// Usage
public class Main {
    public static void main(String[] args) {
        VendingMachine vm = new VendingMachine();
        vm.insertCash(50); // Cash inserted
        vm.selectProduct("A1"); // Product selected
        vm.cancel(); // Refund
    }
}
```

## Key Takeaways
- State pattern lets you model systems with distinct states and transitions
- Each state encapsulates its own behavior and transitions
- Makes code easier to extend and maintain for complex workflows